<!DOCTYPE html>
<html lang="en">


<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="description" content="Создание векторов" />
  <link rel="canonical" href="http://localhost:4000/matlab_course/2023-09-04-octave-vectors-matrices.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preload" href="/assets/fonts/open-sans-v17-latin-regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/assets/fonts/open-sans-v17-latin-regular.woff" as="font" type="font/woff" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/main.css"/>
  <link rel="alternate" type="application/rss+xml" title="David Prowse" href="/feed.xml" />
  <title>Вектора и матрицы в Matlab/Octave &middot; David Prowse</title>
  
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": "",
        "datePublished": "2023-09-04T04:17:05+03:00",
        "headline": "Вектора и матрицы в Matlab/Octave",
        "url": "http://localhost:4000/matlab_course/2023-09-04-octave-vectors-matrices.html",
        "inLanguage": "en-US",
        "isFamilyFriendly": "true",
        "keywords": "Matlab/Octave",
        "image": "http://localhost:4000/favicon.ico",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "http://localhost:4000/matlab_course/2023-09-04-octave-vectors-matrices.html"
       }
      }
    </script>
  
</head>

<body>
<div class="container">
  <nav class="top-nav">
  <a class="nav-item" href='/'>Главная</a>
  | <a class="nav-item" href='/tags'>Теги</a>
  | <a class="nav-item dark-light-switch" href="#" style="text-decoration: none;"></a>
</nav>

  <hr class="stylish"/>
  <div class="_progress-wrapper">
  <div id="_progress"></div>
</div>

<header>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <h1>Вектора и матрицы в Matlab/Octave</h1>
  <header class="title-tags">
    
    

    
    

    <time datetime="2023-09-04T04:17:05+03:00">
      4 сентября, 2023. Это был понедельник.
    </time>    
    
    <div class="tags-container">
      Опубликовано под тегом <span>
          
            <a class="tags" href="/tags#Matlab/Octave">Matlab/Octave</a>
          
        </span>
      &nbsp;
    </div>
  </header>
</header>

<hr class="stylish" />

<main role="main">

  <article>

    <section class="content">
      <h2 id="создание-векторов">Создание векторов</h2>

<p>Существуют различные способы создания векторов и матриц. Самый простой способ задание вектора – в квадратных скобках <code class="language-plaintext highlighter-rouge">[</code> <code class="language-plaintext highlighter-rouge">]</code>. Например:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a =
   1   4   5
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p>или <code class="language-plaintext highlighter-rouge">b = [2,1,0]</code> (без пробелов)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b =
   2   1   0
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">10</span><span class="p">]</span></code></pre></figure>

<p>или <code class="language-plaintext highlighter-rouge">c = [4;7;10]</code> (без пробелов)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c =
    4
    7
   10
</code></pre></div></div>

<p>или через перенос строки:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c =
    1
    2
    3
</code></pre></div></div>

<p>Список чисел, разделенных пробелами или запятыми внутри квадратных скобок, определяет вектор-строку. Числа, разделенные точкой с запятой или переносом строки определяют вектор-столбец.</p>

<p>Можно создать вектор из уже существующего, добавив его в определение. Например:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a =
   1   4   5
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="mi">6</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b =
   1  4  5  6
</code></pre></div></div>

<h2 id="нотация-с-двоиточием">Нотация с двоиточием</h2>

<p>Удобный способ создания вектора из последовательных чисел — использование символа двоеточия “:”, например:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="p">:</span><span class="mi">6</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e =
   2  3  4  5 6
</code></pre></div></div>

<p>Двоеточие указывает Matlab/Octave создать вектор чисел, начиная с первого числа и заканчивая вторым числом (включительно). Также можно добавить третье число между первым и вторым, получая a : b : c. Среднее число в этом случае задает шаг между элементами вектора.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="p">:</span><span class="mf">0.3</span><span class="p">:</span><span class="mi">4</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e =
    2.0000    2.3000    2.6000    2.9000    3.2000    3.5000    3.8000
</code></pre></div></div>

<p>Обратите внимание, если шаг не позволяет точно достичь конечного числа, будут сгенерированы числа, не превышающие его. Шаг может быть отрицательным, и тогда числа будут убывать до конечного значения.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mf">0.3</span><span class="p">:</span><span class="mi">2</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e =
    4.0000    3.7000    3.4000    3.1000    2.8000    2.5000    2.2000
</code></pre></div></div>

<h2 id="функции-создания-векторов">Функции создания векторов</h2>

<p>Matlab/Octave также предлагает набор функций для создания векторов:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zeros(M,N)</code> – cоздает матрицу, в которой каждый элемент равен нулю. Для вектора-строки размера n установите M = 1, N = n;</li>
  <li><code class="language-plaintext highlighter-rouge">ones(M,N)</code> – cоздает матрицу, в которой каждый элемент равен единице. Для вектора-строки размера n установите M = 1, N = n;</li>
  <li><code class="language-plaintext highlighter-rouge">linspace(x1, x2, N)</code> – cоздает вектор из N элементов, равномерно распределенных между x1 и x2;</li>
  <li><code class="language-plaintext highlighter-rouge">logspace(x1, x2, N)</code> – cоздаeт вектор из N элементов, логарифмически распределенных между \(10^{x1}\) и \(10^{x2}\).</li>
</ul>

<p>Первые две функции, <code class="language-plaintext highlighter-rouge">zeros</code> и <code class="language-plaintext highlighter-rouge">ones</code>, также работают для матриц, и два аргумента функции, <code class="language-plaintext highlighter-rouge">M</code> и <code class="language-plaintext highlighter-rouge">N</code>, указывают количество строк и столбцов в матрице соответственно. Вектор-строка — это матрица, которая имеет одну строку и столько же столбцов, каков размер вектора.</p>

<h2 id="отображение-больших-векторов-и-матриц">Отображение больших векторов и матриц</h2>

<p>При работе с большими векторами и матрицами полезно иметь возможность выводить результаты постранично. Для включения постраничного просмотра:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">more</span> <span class="n">on</span></code></pre></figure>

<p>Нажмите пробел (или ‘f’), чтобы просмотреть следующую страницу значений, и используйте клавишу “q”, чтобы закрыть отображение и вернуться к командной строке Matlab/Octave. Вы также можете использовать клавишу ‘b’ для прокрутки назад вверх по отображаемым значениям.</p>

<p>Постраничный просмотр не всегда удобен, например, при отображении промежуточных значений во время длительных расчетов. Для отключения постраничного просмотра:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">more</span> <span class="n">off</span></code></pre></figure>

<h2 id="извлечение-элементов-из-вектора">Извлечение элементов из вектора</h2>

<p>Индивидуальные элементы вектора извлекаются обычными скобками <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">)</code> и нумеруются с 1, а не с 0. Создадим вектор:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a =
    1   3    5    -1    0
</code></pre></div></div>

<p>тогда, чтобы извлечь 3-ий элемент:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    5
</code></pre></div></div>

<p>Нотация с двоеточием может использоваться для извлечения элементов индексы которых принадлежат заданному диапазону:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    5   -1   0
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    1   5   0
</code></pre></div></div>

<h2 id="операции-с-векторами">Операции с векторами</h2>

<p>Сохранение чисел в одном векторе в Matlab/Octave позволяет эффективно проводить расчеты. В отличие от некоторых других Я.П., где для умножения каждого элемента на 2 нужен цикл for, в Matlab/Octave можно использовать векторные операции. <strong><em>Умножение всех чисел вектора на одно число</em></strong> сводится к умножению всего вектора на это число:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    2   6   10   -2   0
</code></pre></div></div>

<p>То же верно и для деления. Также можно добавить одно и то же число к каждому элементу, используя операторы <code class="language-plaintext highlighter-rouge">+</code> или <code class="language-plaintext highlighter-rouge">-</code>, хотя это не соответствует классическим математическим конвенциям.</p>

<p>Умножение двух векторов в Matlab/Octave следует правилам умножения матриц и не является поэлементным умножением. Чтобы вполнить  <strong><em>поэлементное умножение двух векторов</em></strong>, Matlab/Octave определяет операторы <code class="language-plaintext highlighter-rouge">.*</code> и <code class="language-plaintext highlighter-rouge">./</code>, например:</p>

\[\begin{align}
  \begin{pmatrix}
    a_1 \\
    a_2 \\
    a_3 \\
  \end{pmatrix}
\space
.*
\space
  \begin{pmatrix}
    b_1 \\
    b_2 \\
    b_3 \\
  \end{pmatrix}
=
  \begin{pmatrix}
    a_1 b_1 \\
    a_2 b_2 \\
    a_3 b_3 \\
  \end{pmatrix}
\end{align}\]

<p>Точка перед символами указывает на поэлементную операцию. Так, элементы вектора <code class="language-plaintext highlighter-rouge">a</code> можно умножить на разные числа:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">.*</span> <span class="n">b</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    1   6   15   -4   0
</code></pre></div></div>

<p>Оператор поэлементного  возведения в степень  <code class="language-plaintext highlighter-rouge">.^</code> бывает полезен. Он может быть использован для возведения вектора чисел в степень или для возведения числа в разные степени, в зависимости от того, как он используется (аналогично возможно при работе с другими операторами):</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">.*</span> <span class="mi">2</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    1   4   9   16   25
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="o">.*</span> <span class="n">b</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 
    2   4   8   16   32
</code></pre></div></div>

<p>В первом примере каждый элемент <code class="language-plaintext highlighter-rouge">b</code> возведен в квадрат; во втором число <code class="language-plaintext highlighter-rouge">2</code> возведено в степени, указанные в <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>Все поэлементные команды для векторов (<code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">-</code> <code class="language-plaintext highlighter-rouge">./</code> <code class="language-plaintext highlighter-rouge">.*</code> <code class="language-plaintext highlighter-rouge">.^</code>) могут быть использованы между двумя векторами, при условии что они имеют одинаковый <em>размер</em> и <em>форму</em>. В противном случае соответствующие элементы не будут найдены, и будет выдана ошибка.</p>

<p>Большинство функций в Matlab/Octave работают с векторами. Например, чтобы создать список значений синуса с интервалами в 60 градусов, вам просто нужно передать вектор углов функции <code class="language-plaintext highlighter-rouge">sin</code>:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">pi</span><span class="p">/</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>angles =
        0   1.0472   2.0944   3.1416   4.1888   5.2360   6.2832
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y =
        0   0.8660   0.8660   0.0000  -0.8660  -0.8660  -0.0000
</code></pre></div></div>

<h2 id="изменение-значений-в-векторе">Изменение значений в векторе</h2>

<p><strong>Изменение одного значения</strong></p>

<p>Для изменения одного конкретного элемента в векторе в Matlab/Octave указывается индекс этого элемента и присваивается новое значение. Например:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v =
    1   10    3    4    5
</code></pre></div></div>

<p><strong>Изменение нескольких значений</strong></p>

<p>Если требуется изменить несколько элементов в векторе:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v =
    1   20   30   40    5
</code></pre></div></div>

<p><strong>Изменение значений с шагом</strong></p>

<p>Можно также изменять значения с определенным шагом. Например, для замены всех элементов на нечетных позициях на 0:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v =
    0   20    0   40    0
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">1:2:end</code> – Эта часть создаёт новую последовательность индексов, которая начинается с первого элемента (<code class="language-plaintext highlighter-rouge">1</code>), увеличивается с шагом <code class="language-plaintext highlighter-rouge">2</code> и продолжается до последнего элемента (<code class="language-plaintext highlighter-rouge">end</code>) вектора <code class="language-plaintext highlighter-rouge">v</code>.</p>

<p><strong>Использование условных операторов для изменения значений</strong></p>

<p>Для изменения элементов, удовлетворяющих определенному условию, применяются условные операторы. Например, для замены всех элементов больше 30 на 0:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v =
    0   20    0    0    0
</code></pre></div></div>

<p>Эти методы можно комбинировать и адаптировать для решения различных задач.</p>

<h2 id="создание-матриц">Создание матриц</h2>

<p>Векторы являются частными случаями матриц. Матрица — это прямоугольный массив чисел, размер которого обычно описывается как m × n, что означает, что у неё m строк и n столбцов. Например, вот 2 × 3 матрица:</p>

\[A=
\begin{bmatrix}
5 &amp; 7 &amp; 9\\
-1 &amp; 3 &amp; -2
\end{bmatrix}\]

<p>Для ввода этой матрицы в Matlab/Octave воспользуемся синтаксисом, аналогичный векторам, вводя её построчно:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span>
<span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">3</span> <span class="o">-</span><span class="mi">2</span>
<span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A =
   5   7   9
  -1   3  -2
</code></pre></div></div>

<p>В качестве альтернативы, можно использовать точки с запятой для обозначения конца строк:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span>  <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>B =
   2   0
   0  -1
   1   0
</code></pre></div></div>

<p>Также можно использовать нотацию с двоеточием:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">;</span> <span class="mi">8</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C =
   1   2   3
   8   6   4
</code></pre></div></div>

<p>Последней альтернативой является построение матрицы построчно (это особенно удобно для создания таблиц результатов в цикле for):</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">];</span>
<span class="o">&gt;&gt;</span> <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">];</span>
<span class="o">&gt;&gt;</span> <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">;</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D =
   1   2   3
   4   5   6
   7   8   9
</code></pre></div></div>

<h2 id="умножение-матриц">Умножение матриц</h2>

<p>В случае векторов и матриц символ <code class="language-plaintext highlighter-rouge">*</code> обозначает умножение матриц. Например (используя матрицы, определенные выше):</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="n">B</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   19   -7
   -4   -3
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">B</span><span class="o">*</span><span class="n">C</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   2   4   6
  -8  -6  -4
   1   2   3
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="n">C</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: operator *: nonconformant arguments (op1 is 2x3, op2 is 2x3)
</code></pre></div></div>

<p>Выполнить <code class="language-plaintext highlighter-rouge">A*C</code> не удастся, так как формы этих двух матриц несовместимы.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>Для <strong><em>скалярного произведения двух векторов</em></strong>, например <code class="language-plaintext highlighter-rouge">a=[1 2 3]</code> и <code class="language-plaintext highlighter-rouge">b=[4 5 6]</code>, необходимо использовать функцию <code class="language-plaintext highlighter-rouge">dot</code>:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></code></pre></figure>

<p>или <code class="language-plaintext highlighter-rouge">dot(b, a)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 32
</code></pre></div></div>

<p>или оператор <code class="language-plaintext highlighter-rouge">*</code> с транспонированием:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">'</span></code></pre></figure>

<p>или <code class="language-plaintext highlighter-rouge">b * a'</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 32
</code></pre></div></div>

<p><em>Тензерное произведение векторов:</em></p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="o">'</span> <span class="o">*</span> <span class="n">b</span></code></pre></figure>

<p>или <code class="language-plaintext highlighter-rouge">b' * a</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
    4    5    6
    8   10   12
   12   15   18
</code></pre></div></div>

<p>При работе с абстракциями языка программирования, можно забыть про абстракции на математическом уровне. Тем не менее, необходимо помнить, что вектор-строка – матрица размером \(1 \times n\), не может буть умножена справа на матрицу размером  \(m \times n\):</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">];</span>
<span class="o">&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span>
<span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">3</span> <span class="o">-</span><span class="mi">2</span>
<span class="p">];</span>
<span class="o">&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: operator *: nonconformant arguments (op1 is 2x3, op2 is 1x3)
</code></pre></div></div>

<h2 id="оператор-транспонирования">Оператор транспонирования</h2>

<p>Транспонирование вектора преобразует его из строчного вектора в столбцовый и наоборот. Транспонирование матрицы меняет местами строки и столбцы. Математически транспонированная матрица \(A\) обозначается как \(A^T\). В Matlab/Octave апостроф выполняет эту операцию:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A =
   5   7   9
  -1   3  -2
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="o">'</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   5  -1
   7   3
   9  -2
</code></pre></div></div>

<h2 id="функции-создания-матриц">Функции создания матриц</h2>

<p>Matlab/Octave предоставляет некоторые функции для создания специализированных матриц. Мы уже знакомы с функциями <code class="language-plaintext highlighter-rouge">ones</code> и <code class="language-plaintext highlighter-rouge">zeros</code>, которые создают матрицы заданного размера, заполненные 1 или 0.</p>

<p>Важной матрицей является единичная. При умножении она не меняет другие матрицы или векторы. В формулах обычно обозначается как \(I\), а в Matlab/Octave функция для создания <strong><em>единичной матрицей</em></strong> называется <code class="language-plaintext highlighter-rouge">eye</code> (созвучно с буквой). Эта функция принимает один параметр, так как матрица должна быть квадратной:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">I</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I =

Diagonal Matrix

   1   0   0   0
   0   1   0   0
   0   0   1   0
   0   0   0   1
</code></pre></div></div>

<p>Можно проверить, что это не изменяет какой-либо  вектор или матрицу, например:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">I</span> <span class="o">*</span> <span class="p">[</span><span class="mi">5</span><span class="p">;</span> <span class="mi">8</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">0</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   5
   8
   2
   0
</code></pre></div></div>

<p>Единичная матрица является частным случаем <strong><em>диагональной матрицы</em></strong>, которая равна нулю, за исключением диагональных элементов:</p>

\[D=
\begin{bmatrix}
-1 &amp; 0 &amp; 0 \\
0 &amp; 7 &amp; 0 \\
0 &amp; 0 &amp; 2 \\
\end{bmatrix}\]

<p>Можно создать диагональную матрицу вручную, но Matlab/Octave предоставляет функцию <code class="language-plaintext highlighter-rouge">diag</code>, которая берет вектор и располагает его элементы по диагонали матрицы:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">diag</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="mi">7</span> <span class="mi">2</span><span class="p">])</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =

Diagonal Matrix

  -1   0   0
   0   7   0
   0   0   2
</code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">diag</code> довольно продвинутая: если ее вызвать для матрицы, а не для вектора, она вернёт диагональные элементы этой матрицы. Для ранее определенной матрицы A:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   5
   3
</code></pre></div></div>

<p>Обратим внимание, что матрица не обязательно должна быть квадратной для того, чтобы определить её диагональные элементы. Для прямоугольных матриц диагональ все равно начинается с верхнего левого угла и заканчивается, когда заканчиваются строки или столбцы.</p>

<p>Наконец, иногда полезно создать пустую матрицу, возможно, для последующего добавления в неё элементов. Это можно сделать, определив матрицу с помощью пустой пары квадратных скобок:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E =
   []
</code></pre></div></div>

<h2 id="создание-составных-матриц">Создание составных матриц</h2>

<p>Часто полезно уметь создавать матрицы из меньших компонентов (блочные/клеточные матрицы), и это можно легко сделать, используя базовый синтаксис создания матриц:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">comp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">B</span><span class="p">;</span> <span class="n">A</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>comp =
   1   0   0   2   0
   0   1   0   0  -1
   0   0   1   1   0
   5   7   9   0   0
  -1   3  -2   0   0
</code></pre></div></div>

<p>Необходимо удостовериться, что каждая подматрица имеет подходящий размер и форму, чтобы итоговая составная матрица была прямоугольной. Конечно, Matlab/Octave сообщит, если число строк или столбцов в любой из них будет неправильным.</p>

<p>Операция объединения нескольких матриц в одну только по одной из осей называется конкатенацией. Обычно это делается путем добавления строк одной матрицы к другой (вертикальная конкатенация) или путем добавления столбцов одной матрицы к другой (горизонтальная конкатенация).</p>

<p><strong>Вертикальная конкатенация:</strong></p>

<p>Матрицы объединяются по вертикали, то есть одна матрица размещается под другой. Для этого у объединяемых матриц должно быть одинаковое количество столбцов.</p>

<p>Пример:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">;</span> <span class="n">B</span><span class="p">];</span></code></pre></figure>

<p>Результат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C =
     1     2
     3     4
     5     6
     7     8
</code></pre></div></div>

<p><strong>Горизонтальная конкатенация:</strong></p>

<p>Матрицы объединяются по горизонтали, то есть одна матрица размещается рядом с другой. Для этого у объединяемых матриц должно быть одинаковое количество строк.</p>

<p>Пример:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">];</span></code></pre></figure>

<p>Результат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C =
     1     2     5     6
     3     4     7     8
</code></pre></div></div>

<p>Таким образом, вертикальная и горизонтальная конкатенации в MATLAB/Octave достигаются с помощью операторов <code class="language-plaintext highlighter-rouge">;</code> и <code class="language-plaintext highlighter-rouge">,</code> соответственно.</p>

<h2 id="матрицы-в-качестве-таблиц">Матрицы в качестве таблиц</h2>

<p>Матрицы также можно использовать для удобной организации данных в виде таблиц, что может быть более естественным способом их хранения:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span>  <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.2</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="o">&gt;&gt;</span>  <span class="n">freq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="s1">' sin(2*t)'</span> <span class="nb">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">'</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>freq =
        0        0        0
   0.1987   0.3894   0.5646
   0.3894   0.7174   0.9320
   0.5646   0.9320   0.9738
   0.7174   0.9996   0.6755
   0.8415   0.9093   0.1411
</code></pre></div></div>

<p>В \(n\)-м столбце матрицы содержатся (выборочные) данные для \(\sin(nt)\). В качестве альтернативы можно было бы хранить каждый ряд данных в отдельном векторе с уникальным именем. В таком случае потребовалось бы знать имя каждого вектора для дальнейшего использования данных. Хранение данных в матрице облегчает доступ к ним.</p>

<h2 id="извлечение-данных-из-матрицы">Извлечение данных из матрицы</h2>

<p>Числа можно извлекать из матрицы с использованием той же синтаксической конструкции, что и для векторов, используя круглые скобки <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">)</code>. Для матрицы сначала указывается координата строки, а затем координата столбца (обратим внимание, что в декартовых координатах это сначала \(y\), а затем \(x\)). Некоторые примеры:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">J</span> <span class="o">=</span> <span class="p">[</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span>
<span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span>
<span class="p">];</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 1
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">J</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = 7
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">% Rows 1-2, column 4</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   4
   8
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">J</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">:)</span> <span class="c1">% Row 3, all columns</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
    9   10   11   12
</code></pre></div></div>

<p>Оператор “:” может указывать на диапазон элементов или, если использован сам по себе, на всю строку или столбец.</p>

<p>Такие же выражения можно использовать для записи элементов в матрицу:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">J</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">]</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>J =
    1    2    3    4
    5    6    7    8
    9   -1    0   12
</code></pre></div></div>

<h2 id="базовые-функции-для-работы-с-матрицами">Базовые функции для работы с матрицами</h2>

<p>В Matlab/Octave доступны стандартные арифметические операции с матрицами: умножение, а также сложение и вычитание матриц одинакового размера с помощью операторов <code class="language-plaintext highlighter-rouge">+</code> и <code class="language-plaintext highlighter-rouge">-</code>. Операторы <code class="language-plaintext highlighter-rouge">.*</code> и <code class="language-plaintext highlighter-rouge">./</code> позволяют умножать и делить соответствующие элементы двух матриц. Для возведения всех элементов матрицы в степень используется оператор <code class="language-plaintext highlighter-rouge">.^</code>.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">size</code> возвращает вектор с размерами матрицы: сначала количество строк, затем столбцов.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">size</span><span class="p">(</span><span class="n">J</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   3   4
</code></pre></div></div>

<p>Обратная матрица — это матрица, которая при умножении на исходную матрицу дает единичную матрицу \(AA^{-1} = A^{-1}A = I\). Она “отменяет” эффект исходной матрицы. Определена только для квадратных матриц и в Matlab/Octave может быть найдена с помощью функции <code class="language-plaintext highlighter-rouge">inv</code>:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span>
<span class="mi">3</span> <span class="mi">0</span> <span class="mi">4</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>
<span class="mi">2</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">3</span>
<span class="p">];</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   0.1429  -0.2857   0.2857
   0.1429   1.2143  -0.2143
   0.1429   0.2143  -0.2143
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="nb">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1">% Check the answer</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans =
   1.0000   0.0000  -0.0000
        0   1.0000        0
        0   0.0000   1.0000
</code></pre></div></div>

<p>Обратим внимание на небольшие числовые ошибки, из-за которых Matlab/Octave не определяет некоторые элементы как точные 1 или 0.</p>

<p><em>Определитель матрицы</em> – полезная величина для вычисления. В частности, нулевой определитель указывает на отсутствие обратной матрицы. Функция <code class="language-plaintext highlighter-rouge">det</code> вычисляет определитель:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="o">&gt;&gt;</span> <span class="nb">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans = -14.000
</code></pre></div></div>

<p><strong>Функции создания матриц:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">eye</code> – создать единичную матрицу;</li>
  <li><code class="language-plaintext highlighter-rouge">zeros</code> – создать матрицу из нулей;</li>
  <li><code class="language-plaintext highlighter-rouge">ones</code> –  создать матрицу из единиц;</li>
  <li><code class="language-plaintext highlighter-rouge">rand</code> – cоздать матрицу, заполненную случайными числами;</li>
  <li><code class="language-plaintext highlighter-rouge">diag</code> – cоздать диагональную матрицу или извлечь диагональ из данной матрицы.</li>
</ul>

<p><strong>Базовые операции и свойства матриц:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inv</code> – получить обратную матрицу;</li>
  <li><code class="language-plaintext highlighter-rouge">det</code> – получить определитель матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">trace</code> – след матрицы.</li>
</ul>

<p><strong>Продвинутые операции и свойства матриц:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">eig</code> – вычислить собственные векторы и собственные значения матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">rank</code> – вычислить приближенный ранг матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">null</code> – вычислить базис нулевого пространства матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">rref</code> – выполнить метод Гаусса для расширенной матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">lu</code> – вычислить LU-разложение<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">qr</code> – вычислить QR-разложение<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">svd</code> – вычислить сингулярное разложение (SVD) матрицы;</li>
  <li><code class="language-plaintext highlighter-rouge">pinv</code> – вычислить псевдообратную матрицу.</li>
</ul>

<p><br /></p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>В общем случае, в умножении матриц размеры матриц: \((l \times m) \cdot (m \times n) \rightarrow (l \times n)\). Когда мы пытаемся выполнить <code class="language-plaintext highlighter-rouge">A*C</code>: \((2 \times 3)\cdot(2 \times 3)\), что не соответствует определению. Средняя пара чисел не совпадает, что объясняет формулировку сообщения об ошибке. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>LU-разложение — это представление матрицы в виде произведения двух матриц: нижнетреугольной \(L\) и верхнетреугольной \(U\). То есть, для матрицы \(A\) находятся такие матрицы \(L\) и \(U\), что \(A = L \times U\). <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>QR-разложение — это представление матрицы \(A\) в виде произведения ортогональной матрицы \(Q\) и верхнетреугольной матрицы \(R\). То есть,  \(A = Q \times R\). Ортогональная матрица — это матрица, транспонированная которой равна её обратной: \(Q^T = Q^{-1}\). <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </section>

    <!-- <hr class="stylish"/> -->

    <!-- <aside class="featured-posts">
  <h3></h3>
  <ul>
    
  </ul>
</aside>
 -->

    <!-- <hr class="stylish"/> -->

    <section class="pagination">
      
      <a class="prev" href="/matlab_course/2023-09-04-octave-intro.html">&laquo; Введение в Matlab/Octave</a>
      
      
      <a class="next" href="/matlab_course/2023-09-11-octave-matrix-algebra.html">Матричная алгебра в Matlab/Octave &raquo;</a>
      
    </section>

  </article>

</main>

</div>
<footer>
  <hr class="stylish"/>
  <nav class="top-nav">
  <a class="nav-item" href='/'>Главная</a>
  | <a class="nav-item" href='/tags'>Теги</a>
  | <a class="nav-item dark-light-switch" href="#" style="text-decoration: none;"></a>
</nav>

  <div>
    <br>
    David Prowse &copy; 2023
  </div>
</footer>

  <script src="/assets/main.js"></script>

</body>
</html>
